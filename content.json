{"meta":{"title":"拓伽","subtitle":"一定存在只有你才能做到的事","description":"拓伽的日常分享博客","author":"dcsmf","url":"http://dcsmf.github.io","root":"/"},"pages":[{"title":"","date":"2024-01-21T04:42:33.200Z","updated":"2024-01-21T04:42:33.200Z","comments":true,"path":"404.html","permalink":"http://dcsmf.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":true,"path":"categories/index.html","permalink":"http://dcsmf.github.io/categories/","excerpt":"","text":""},{"title":"所有标签","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":true,"path":"tags/index.html","permalink":"http://dcsmf.github.io/tags/","excerpt":"","text":""},{"title":"","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":true,"path":"custom/darkmode-animation/main.css","permalink":"http://dcsmf.github.io/custom/darkmode-animation/main.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":true,"path":"custom/darkmode-animation/main.js","permalink":"http://dcsmf.github.io/custom/darkmode-animation/main.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); volantis.dark.push(switchNightMode);"},{"title":"","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":false,"path":"page/about/index.html","permalink":"http://dcsmf.github.io/page/about/","excerpt":"","text":"站长是个咸鱼，什么都不会，只能做做笔记这样子 这是我很喜欢的一句话，也送给你： 「一定存在只有你才能做到的事」 本站由 WordPress Typecho Hexo 强力驱动，使用 Volantis 主题"},{"title":"我的朋友们","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":true,"path":"page/friends/index.html","permalink":"http://dcsmf.github.io/page/friends/","excerpt":"","text":"请按照以下格式回复哦： - title: # 名称 avatar: # 头像 url: # 链接"},{"title":"","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":false,"path":"page/history/index.html","permalink":"http://dcsmf.github.io/page/history/","excerpt":"","text":"建站史这里简略了记述了本站的发展历史，不定期更新。 未完待续 2022&#x2F;04&#x2F;21 发布第一篇文章《Java中的联合类型》 2022&#x2F;04&#x2F;20 中间断断续续，但终于接近完工可以开始写博客了 2021&#x2F;12&#x2F;25 在尝试WordPress、Typecho后选择了Hexo并由此开始搭建博客之旅"},{"title":"RSS订阅","date":"2024-01-21T04:42:33.208Z","updated":"2024-01-21T04:42:33.208Z","comments":false,"path":"page/rss/index.html","permalink":"http://dcsmf.github.io/page/rss/","excerpt":"","text":"你可以在下面链接处订阅本博客最新的 20 篇文章 RSS 订阅地址/atom.xml"}],"posts":[{"title":"在终端打印彩色字体","slug":"在终端打印彩色字体","date":"2024-01-15T13:40:23.000Z","updated":"2024-01-21T04:42:33.204Z","comments":true,"path":"post/3bd7e928/","link":"","permalink":"http://dcsmf.github.io/post/3bd7e928/","excerpt":"","text":"简单打印我们要打印一些特殊的字符来让终端识别，在这里需要使用ESC转义字符 先看示例：\\033[1m 代码解释： 输出ESC转义字符，这是不可见字符，需要借助 ANSI 编码来获得，比如使用\\033或者\\u001b [字符，表示开始定义，是中括号 控制编码，如下表 m字符，表示结束定义，是英文的 m 字母 常用的控制编码表（不完整）： 控制编码 作用 备注 0 重置 去除所有的效果 1 加粗 2 变细 部分终端不支持 3 斜体 部分终端不支持 4 下划线 5 缓慢闪烁 每分钟 150 次以下，部分终端不支持 6 快速闪烁 每分钟 150 次以上，部分终端不支持 7 反显 将前景色与背景色交换 8 隐藏 让输出变得透明，部分终端不支持 9 删除线 部分终端不支持 21 取消粗体并添加双下划线 部分终端不支持 53 上划线 部分终端不支持 简单的 demo 代码： // 输出加粗的字体System.out.println(&quot;\\033[1m&quot; + &quot;Hello, World!&quot; + &quot;\\033[0m&quot;); 请注意使用完后一定要使用\\033[0m进行还原，以免影响之后自己或其它程序的输出 让打印输出变得五彩斑斓起来讲完了基础的使用方法，接下来就可以进入正题，如何输出彩色字体 3&#x2F;4 位的简单 8 色输出颜色在这里分为前景色和背景色两种，前景色可以就理解为字体的颜色 最简单的颜色更改代码：\\033[控制编码m 最简单的 8 色输出可以用的编码： 前景色编码 背景色编码 代表颜色 前景色编码 背景色编码 代表颜色 30 40 黑色 90 100 亮黑（灰色） 31 41 红色 91 101 亮红 32 42 绿色 92 102 亮绿 33 43 黄色 93 103 亮黄 34 44 蓝色 94 104 亮蓝 35 45 品红 95 105 亮品红 36 46 青色 96 106 亮青 37 47 白色 97 107 亮白 最终呈现的颜色取决于不同的终端模拟器，即不同的终端显示的颜色会有偏差 让色彩多起来，使用 8 位的 256 色输出8 色输出太少了，如果需要更多的颜色怎么办呢？ 这就需要用到如下的代码了： 前景色更改代码：\\033[38;5;颜色编码m或者\\033[38;2;r;g;bm 前景色更改代码：\\033[48;5;颜色编码m或者\\033[48;2;r;g;bm 这里的 38、48、5 和 2 都是固定的，不可以变，我们需要的只是填充颜色编码或者 rgb 的值 对应的颜色编码这里有一个图 256色颜色编码表 颜色编码取值是 0-255 这个范围 0-7 对应控制编码中的标准 8 色，8-15 对应控制编码中的亮 8 色 直接使用对应的控制编码会更加方便 16-231 对应相应的 rgb 值，并且 0 &lt;&#x3D; r, g, b &lt;&#x3D; 5 232-255 对应从黑到白的 24 阶灰度色 我们来一点示例代码： // 输出颜色编码为22的前景色System.out.println(&quot;\\033[38;5;22m&quot; + &quot;Hello, World!&quot; + &quot;\\033[0m&quot;);// 你当然还可以组合使用// 输出加粗的，颜色编码为22的前景色// 组合使用System.out.println(&quot;\\033[1;38;5;22m&quot; + &quot;Hello, World!&quot; + &quot;\\033[0m&quot;);// 分开使用，推荐System.out.println(&quot;\\033[1m&quot; + &quot;\\033[38;5;22m&quot; + &quot;Hello, World!&quot; + &quot;\\033[0m&quot;); 五彩缤纷，使用 24 位颜色随着 16 位到 24 位颜色的“真彩色”显卡的普及，很多终端都支持了 24 位的颜色 还是使用如下代码： 前景色更改代码：\\033[38;2;r;g;bm 前景色更改代码：\\033[48;2;r;g;bm 只是这里的 r,g,b 没有像 8 位颜色那样的 0-5 的范围限制了，你可以寻找任意的 RGB 颜色值进行填充！ 第三方库如果不想记忆这些编码，可以使用定义好这些颜色的第三方库，如 JColor GitHub：https://github.com/dialex/JColor maven 仓库：https://mvnrepository.com/artifact/com.diogonunes/JColor 使用例子（来自其 GitHub README.md）： // 使用情况1: 使用 Ansi.colorize() 方法在内联中格式化System.out.println(colorize(&quot;这段是品红背景下的黄色文字&quot;, YELLOW_TEXT(), MAGENTA_BACK()));System.out.println(&quot;\\n&quot;);// 使用情况2: 创建 Attributes 数组去定义格式化样式Attribute[] myFormat = new Attribute[]&#123;RED_TEXT(), YELLOW_BACK(), BOLD()&#125;;System.out.println(colorize(&quot;这段是黄色背景下的红色加粗文字&quot;, myFormat));System.out.println(&quot;\\n&quot;);// 使用情况3: AnsiFormat 是 Attributes 数组的语法糖AnsiFormat fWarning = new AnsiFormat(GREEN_TEXT(), BLUE_BACK(), BOLD());System.out.println(colorize(&quot;AnsiFormat 是声明格式化的一种很优雅的方式&quot;, fWarning));System.out.println(fWarning.format(&quot;使用这种方式就不需要直接调用 colorize() 方法&quot;));System.out.println(&quot;\\n&quot;);// 使用情况4: 也支持亮色AnsiFormat fNormal = new AnsiFormat(MAGENTA_BACK(), YELLOW_TEXT());AnsiFormat fBright = new AnsiFormat(BRIGHT_MAGENTA_BACK(), BRIGHT_YELLOW_TEXT());System.out.println(fNormal.format(&quot;你可以使用普通的颜色&quot;) + fBright.format(&quot;以及亮色版本&quot;));// 使用情况5: 使用8位颜色System.out.println(&quot;支持任何你终端支持的 8-bit 颜色&quot;);for (int i = 0; i &lt;= 255; i++) &#123; Attribute txtColor = TEXT_COLOR(i); System.out.print(colorize(String.format(&quot;%4d&quot;, i), txtColor));&#125;System.out.println(&quot;\\n&quot;);// 使用情况6: 使用RGBSystem.out.println(&quot;支持任何你终端支持的 RGB 颜色&quot;);for (int i = 0; i &lt;= 300; i++) &#123; Attribute bkgColor = BACK_COLOR(new Random().nextInt(255), new Random().nextInt(255), new Random().nextInt(255)); System.out.print(colorize(&quot; &quot;, bkgColor));&#125;System.out.println(&quot;\\n&quot;);// 版权信息System.out.print(&quot;This example used JColor 5.0.0 &quot;);System.out.print(colorize(&quot;\\tMADE &quot;, BOLD(), BRIGHT_YELLOW_TEXT(), GREEN_BACK()));System.out.println(colorize(&quot;IN PORTUGAL\\t&quot;, BOLD(), BRIGHT_YELLOW_TEXT(), RED_BACK()));System.out.println(&quot;I hope you find it useful ;)&quot;);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"},{"name":"shell","slug":"shell","permalink":"http://dcsmf.github.io/tags/shell/"}],"author":"dcsmf"},{"title":"Java常见坑总结","slug":"Java常见坑总结","date":"2023-12-17T07:39:59.000Z","updated":"2024-01-21T04:42:33.204Z","comments":true,"path":"post/466d2d9/","link":"","permalink":"http://dcsmf.github.io/post/466d2d9/","excerpt":"","text":"ProcessBuilder类这个类用于执行shell命令，类似于Runtime.getRuntime().exec(&quot;ping -t 192.168.0.1&quot;) 但在使用它的command方法时，需要注意要把命令分开传入 它的签名为： public ProcessBuilder command(String... command) 如果传入一整个完整的带空格的命令则会无法正确执行 比如要执行ping -t 192.168.0.1，需要分别传入&quot;ping&quot;、&quot;-t&quot;和&quot;192.168.0.1&quot; 如果是现成的命令，可以使用&quot;命令&quot;.split(&quot; &quot;)把命令通过空格进行分割成String数组","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"}],"author":"dcsmf"},{"title":"gradle的全局镜像和编码设置","slug":"gradle的全局镜像和编码设置","date":"2023-09-24T06:39:21.000Z","updated":"2024-01-21T04:42:33.204Z","comments":true,"path":"post/fb76cefb/","link":"","permalink":"http://dcsmf.github.io/post/fb76cefb/","excerpt":"","text":"前期准备默认位置首先需要找到你的gradle在哪 如果没有.gradle文件夹，请新建一个 Windows系统默认是在%USERPROFILE%即C:\\Users\\用户名下面的.gradle文件夹 MacOS&#x2F;Linux默认在~/.gradle 自定义位置如果想自定义gradle下载和仓库的位置的话 Windows可以在高级系统设置-&gt;高级-&gt;环境变量里新建名为GRADLE_USER_HOME的变量，并将内容填写为你需要的地方，比如我填写的就是D:\\Program\\Tools\\.gradle MacOS&#x2F;Linux可以使用两种方式，选择其一即可 方式一：配置环境变量rm -rf ~/.gradle # 先删除原来的.gradle文件夹echo &quot;export GRADLE_USER_HOME=你自定义的目录&quot; &gt;&gt; .bashrc # 如果用的bashecho &quot;export GRADLE_USER_HOME=你自定义的目录&quot; &gt;&gt; .zshrc #如果用的zsh 方式二：软链接这里把/media/common/linux/gradle链接到~/.gradle rm -rf ~/.gradleln -s /media/common/linux/gradle ~/.gradle 配置镜像由于gradle没有提供和maven一样的settings.xml全局配置文件，所以我们得新建文件 对于groovy DSL的init.gradleallprojects &#123; repositories &#123; maven &#123; url &#x27;https://maven.aliyun.com/repository/public/&#x27; &#125; mavenLocal() mavenCentral() &#125;&#125;settingsEvaluated &#123; settings -&gt; settings.pluginManagement &#123; repositories &#123; maven &#123; url &quot;https://maven.aliyun.com/repository/gradle-plugin&quot; &#125; gradlePluginPortal() &#125; &#125;&#125; 对于kotlin DSL的init.gradle.ktsallprojects &#123; repositories &#123; maven(&quot;https://maven.aliyun.com/repository/public/&quot;) mavenLocal() mavenCentral() &#125;&#125;settingsEvaluated &#123; settings -&gt; settings.pluginManagement &#123; repositories &#123; maven(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;) gradlePluginPortal() &#125; &#125;&#125; 配置编码gradle里面写的中文经常会乱码 特别是Windows下，默认用的gbk编码，而其它地方又用utf8编码，就会造成乱码问题 也还是在.gradle文件夹下新建文件 gradle.propertiesorg.gradle.parallel = true # 这行可以开启并行处理org.gradle.jvmargs = &#x27;-Dfile.encoding=UTF-8&#x27; 最终结果上面配置好后，你的.gradle文件夹应该是这个样子 .gradle/|-- init.gradle|-- init.gradle.kts|-- gradle.properties","categories":[{"name":"编程杂谈","slug":"编程杂谈","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://dcsmf.github.io/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"http://dcsmf.github.io/tags/Gradle/"}],"author":"dcsmf"},{"title":"Java的常用@SuppressWarnings注解","slug":"Java的常用-SuppressWarnings注解","date":"2023-09-17T12:02:08.000Z","updated":"2024-01-21T04:42:33.204Z","comments":true,"path":"post/8809bc/","link":"","permalink":"http://dcsmf.github.io/post/8809bc/","excerpt":"","text":"总所周知，IDE经常会提示一些警告，通常使用@SuppressWarnings注解来忽略 虽然这样做并不是很推荐，但对于一些不想改动的代码还是需要的，所以在这里做个我常用的记录 值 备注 ResultOfMethodCallIgnored 返回值忽略 unused 未使用的变量 DuplicatedCode 重复的代码 unchecked 未经检查的转换，经常使用 deprecation 使用弃用的方法 rawtypes 形参化的原始使用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"}],"author":"dcsmf"},{"title":"如何通过GitHub Actions部署跨平台的Rust程序","slug":"如何通过GitHub-Actions部署跨平台的Rust程序","date":"2023-07-02T03:44:26.000Z","updated":"2024-01-21T04:42:33.200Z","comments":true,"path":"post/40f7a3b2/","link":"","permalink":"http://dcsmf.github.io/post/40f7a3b2/","excerpt":"","text":"本文是How to Deploy Cross-Platform Rust Binaries with GitHub Actions的翻译版本 当你准备发布你第一版的Rust工程时，大概率会要上传一些适配macOS、Linux和Windows的预构建程序到你的GitHub release页面。这是让你的程序大范围可用的最初一步，也极大的方便你为Homebrew设置各种安装方法。 然而，需要指出的是，交叉编译并不是一件容易的事，尤其是使用GitHub Action来做。 在本文的最后，你将会得到一个健全的部署流程，它可以自动创建releases并上传Windows、Linux和macOS各自的二进制程序。 你的releases页看起来将会是这个样子： 你甚至还能学到一些GitHub Actions的知识！ 工作流触发器首先我们需要设置触发action的条件。 通常情况下，软件发布每个版本时都会新建一个对应的标签，所以我们可以设置自动发布器运行的条件为：当一个新的标签推送(pushed)到GitHub的时候。 我们还需要限制一下标签的内容是具体的版本号(比如1.0.0或者0.2.4之类的)时才触发，这样GitHub才不会在我们新建不相关的标签时运行我们的action。 我们可以用以下代码做到： .github/workflows/deploy.yml# 设置我们action的名字，自定义name: Deployon: push: tags: # 通过正则匹配一个版本，比如0.2.1 - &quot;[0-9]+.[0-9]+.[0-9]+&quot; 好了，解决了上述触发的问题后，我们来看看我们的action具体要做些什么吧！ 构建Action为了编译我们的跨平台程序，我们需要创建一个新的作业(job)，我们可以叫它build-and-upload，因为它负责构建二进制程序并上传到release页面。 一个作业(job)绑定了一系列的步骤(steps)，在步骤分类下我们可以做几乎任何事情！ 定义元数据让我们开始写我们的工作流程，首先我们需要定义整个流程中所需要用到的一些元数据。 .github/workflows/deploy.yml# ...jobs: # ... build-and-upload: name: Build and upload # 此作业运行在什么操作系统上 runs-on: $&#123;&#123; matrix.os &#125;&#125; # strategy上下文，有关当前作业的矩阵执行策略的信息 strategy: # matrix上下文，包含在工作流中定义的应用于当前作业的矩阵属性 matrix: # 你可以添加更多你想要的构建平台 include: - build: linux os: ubuntu-latest target: x86_64-unknown-linux-musl - build: macos os: macos-latest target: x86_64-apple-darwin - build: windows-gnu os: windows-latest target: x86_64-pc-windows-gnu 你可能注意到了matrix，这个matrix是很重要的一部分，我们的工作会遍历在matrix里包含(include)的每一个元素。matrix在runs-on这个关键字中用到了，所以我们的build-and-upload作业会在每一个os键所示的操作系统中运行一次。 安装依赖这之后我们开始添加作业的步骤，最开始的两步很简单：克隆(clone)我们的仓库并安装Rust .github/workflows/deploy.yml# ...build-and-upload: # ... steps: - name: Clone repository uses: actions/checkout@v3 - name: Install Rust # 安装Rust的稳定版本 # 也可以使用@nightly来下载测试版 uses: dtolnay/rust-toolchain@stable # 运行此步骤提供的参数 with: # 让Rust编译到我们所需要的平台(这已经定义在matrix关键字里了) targets: $&#123;&#123; matrix.target &#125;&#125; 这一步使用了uses关键字，它会告诉执行器调用一个外部的别人已经做好了的action。 你可以在GitHub看到我们具体调用的这个actions&#x2F;checkout，它用来克隆我们的仓库到本地。 使用with关键字来定义所需要的参数，我们用它来设置dtolnay&#x2F;rust-toolchain，告诉它我们的Rust应该编译到哪个平台。 得到版本信息然后来得到标签里的版本信息，我们待会会用到。 .github/workflows/deploy.yml- name: Get the release version from the tag shell: bash run: echo &quot;VERSION=$&#123;GITHUB_REF#refs/tags/&#125;&quot; &gt;&gt; $GITHUB_ENV 你可能注意到了shell: bash，这告诉GitHub Actions我们想要运行一个shell脚本，然后在run关键字里输入我们想执行的命令。 这个脚本会把从标签里得到的版本信息放到环境变量里，叫$VERSION。 在不同步骤中通信时，使用环境变量是非常常见的做法。我们可以在之后的作业中使用$&#123;&#123;env.VERSION&#125;&#125;来得到这里设置的版本信息(如0.1.0)。 构建二进制程序准备工作做完后，我们现在就可以来构建二进制程序了。 这一步我们会使用cross这个工具，它使用Docker来构建跨平台的工程。也已经有了非常简单的action来让我们用cross。 让我们把它放到步骤数组里： .github/workflows/deploy.yml- name: Build uses: actions-rs/cargo@v1 with: use-cross: true command: build args: --verbose --release --target $&#123;&#123; matrix.target &#125;&#125; 这一步告诉GitHub Actions我们想要使用cross来构建我们的工程。 类似于cargo build，我们的程序会被构建到target/&lt;TARGET&gt;/release/&lt;BINARY_NAME&gt;，这里的&lt;TARGET&gt;就是我们在matrix里定义的target键，名字则取决于你的项目。 压缩二进制程序我们快要完成了！现在我们得到了构建完成的二进制程序，现在需要把它们放到.tar.gz或者.zip压缩文件里，这样其他人就能方便的从我们的assets页下载了。 通过以下步骤可以做到： .github/workflows/deploy.yml- name: Build archive shell: bash run: | # 使用你程序的名称替换下面这个名字 binary_name=&quot;&lt;BINARY_NAME&gt;&quot; dirname=&quot;$binary_name-$&#123;&#123; env.VERSION &#125;&#125;-$&#123;&#123; matrix.target &#125;&#125;&quot; mkdir &quot;$dirname&quot; if [ &quot;$&#123;&#123; matrix.os &#125;&#125;&quot; = &quot;windows-latest&quot; ]; then mv &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$binary_name.exe&quot; &quot;$dirname&quot; else mv &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$binary_name&quot; &quot;$dirname&quot; fi if [ &quot;$&#123;&#123; matrix.os &#125;&#125;&quot; = &quot;windows-latest&quot; ]; then 7z a &quot;$dirname.zip&quot; &quot;$dirname&quot; echo &quot;ASSET=$dirname.zip&quot; &gt;&gt; $GITHUB_ENV else tar -czf &quot;$dirname.tar.gz&quot; &quot;$dirname&quot; echo &quot;ASSET=$dirname.tar.gz&quot; &gt;&gt; $GITHUB_ENV fi 这一步很长，但并不复杂，让我们来拆解一下这一长段做了什么： 创建一个我们将要用来压缩的目录(如prj-0.2.1-x86_64-apple-darwin) 把我们构建好的二进制程序放到这个目录里，不同操作系统会有不同的名字 压缩，Windows使用.zip，Unix使用.tar.gz 把压缩文件的路径放到名为$ASSET的环境变量里 我们之前定义的$VERSION也在这里使用到了！ 上传二进制程序压缩完后，我们就准备上传了，这是我们作业的最后一个步骤！ .github/workflows/deploy.yml- name: Upload the binaries uses: softprops/action-gh-release@v1 with: files: | $&#123;&#123; env.ASSET &#125;&#125; 相比于其他步骤，这一步无疑非常好理解了。 我们只需要使用别人写好的softprops&#x2F;action-gh-release来上传我们的文件即可（上一步我们把文件存到了$ASSET环境变量中） 然后就完成了！当我们把带有一个版本标签（如2.1.0）的修改推送到GitHub时，这个action将会帮我们创建release，构建多平台的二进制文件并上传！ 总结与完整代码我希望本文是轻松有趣又能让人学到知识的，在此祝你未来部署工程时顺风顺水！ 如果对于本文有什么疑问或者困惑，欢迎在GitHub新建一个issue。 作为补充，下面所示的就是一个完整的action代码了（译者注：以下代码与上述代码不完全一致）： 成品action代码 .github/workflows/deploy.ymlname: Deployon: push: tags: - &quot;[0-9]+.[0-9]+.[0-9]+&quot;permissions: contents: writejobs: build-and-upload: name: Build and upload runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: # You can add more, for any target you&#x27;d like! include: - build: linux os: ubuntu-latest target: x86_64-unknown-linux-musl - build: macos os: macos-latest target: x86_64-apple-darwin steps: - name: Checkout uses: actions/checkout@v3 - name: Get the release version from the tag shell: bash run: echo &quot;VERSION=$&#123;GITHUB_REF#refs/tags/&#125;&quot; &gt;&gt; $GITHUB_ENV - name: Install Rust # Or @nightly if you want uses: dtolnay/rust-toolchain@stable # Arguments to pass in with: # Make Rust compile to our target (defined in the matrix) targets: $&#123;&#123; matrix.target &#125;&#125; - name: Build uses: actions-rs/cargo@v1 with: use-cross: true command: build args: --verbose --release --target $&#123;&#123; matrix.target &#125;&#125; - name: Build archive shell: bash run: | # Replace with the name of your binary binary_name=&quot;&lt;BINARY_NAME&gt;&quot; dirname=&quot;$binary_name-$&#123;&#123; env.VERSION &#125;&#125;-$&#123;&#123; matrix.target &#125;&#125;&quot; mkdir &quot;$dirname&quot; if [ &quot;$&#123;&#123; matrix.os &#125;&#125;&quot; = &quot;windows-latest&quot; ]; then mv &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$binary_name.exe&quot; &quot;$dirname&quot; else mv &quot;target/$&#123;&#123; matrix.target &#125;&#125;/release/$binary_name&quot; &quot;$dirname&quot; fi if [ &quot;$&#123;&#123; matrix.os &#125;&#125;&quot; = &quot;windows-latest&quot; ]; then 7z a &quot;$dirname.zip&quot; &quot;$dirname&quot; echo &quot;ASSET=$dirname.zip&quot; &gt;&gt; $GITHUB_ENV else tar -czf &quot;$dirname.tar.gz&quot; &quot;$dirname&quot; echo &quot;ASSET=$dirname.tar.gz&quot; &gt;&gt; $GITHUB_ENV fi - name: Release uses: softprops/action-gh-release@v1 with: files: | $&#123;&#123; env.ASSET &#125;&#125;","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://dcsmf.github.io/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://dcsmf.github.io/tags/GitHub/"},{"name":"Rust","slug":"Rust","permalink":"http://dcsmf.github.io/tags/Rust/"}],"author":"Diego"},{"title":"关于开源协议的选择","slug":"关于开源协议的选择","date":"2022-07-18T10:26:20.000Z","updated":"2024-01-21T04:42:33.200Z","comments":true,"path":"post/2fb0f490/","link":"","permalink":"http://dcsmf.github.io/post/2fb0f490/","excerpt":"","text":"为了了解各个分类的通俗易懂的含义，理解了好久，终于写出来文章了（泪目） 简单的选择阮一峰老师其实写过一篇文章，用中文介绍过6大常用开源协议，即如下图所示： 快速选择6大常用协议 这其实就很足够日常使用了，所以本文完（我才不是水了一篇文章啊） 更多的选择面对更复杂情况或者看到其它开源仓库用的协议，大多数情况还是会一脸懵我们可以把很多开源协议分为3大板块 权限（Permissions）原作者给使用软件的人的权限 这个可以分为5大类： 商用（Commercial use）：软件及其衍生品是否可用在商业用途 分发（Distribution）：是否可以传播软件 修改（Modification）：是否可以修改源代码 专利使用（Patent use）：原作者是否授予专利权 私人使用（Private use）：私下使用和修改的权利 条件（Conditions）给修改、分发软件的人施加的限制条件，需要遵守 这个可以分成8种： 公开来源（Disclose source）： 分发软件时必须带上源代码一起 许可和版权声明（License and copyright notice）： 软件和源码必须带上原作者的许可证和版权声明 源代码许可和版权声明（License and copyright notice for source）： 分发的源码必须带上许可证和版权声明，但二进制软件则不用 网络使用即分发（Network use is distribution）： 通过网络与软件交互的用户，也有权获得该软件的源代码（即这个软件以网站的形式服务用户，那么这个软件也需要能让用户得到相应的源代码） 相同许可证（Same license）： 分发修改后的源代码时需要采用相同的许可证 相同许可证（文件）（Same license (file)）： 分发修改后的源代码时需要采用相同的许可证，且对非源代码的文件（如图片等）进行修改后也如此 相同许可证（库）（Same license (library)）： 分发修改后的源代码时需要采用相同的许可证，但把它作为第三方库使用时则不需要 更改记录（State changes）： 必须有明确的文档记录下对源代码所做的修改 限制（Limitations）关于使用的一些限制，如软件使用出了问题该找谁 有3类情况需要了解 责任（Liability）：原作者不对使用软件所带来的任何后果承担责任 商标使用（Trademark use）：不授予使用作者姓名、软件商标等的权利 保证（Warranty）：协议是否明确写出原作者不提供任何关于软件的担保 这下终于可以更多了解各种协议了，让我们在GitHub随便打开一个项目看看他的协议 MIT协议 看懂了吗？ Permissions 允许商业使用 允许修改 允许分发 允许私人使用 Limitations 作者不承担任何责任 作者不提供任何担保 Conditions 软件和源码必须带上原作者的许可证和版权声明 如果想了解更多协议，可以看看这个网站相应的颜色我也对上了，边看左边的协议名称边对比右边颜色，就可以轻松辨别了 空白表示协议没有提到这一点，绿色和蓝色表示协议明确写出来允许某行为，红色表示协议明确写出来禁止这些行为","categories":[{"name":"编程杂谈","slug":"编程杂谈","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://dcsmf.github.io/tags/%E5%BC%80%E6%BA%90/"}],"author":"dcsmf"},{"title":"Java中常用的Stream流操作","slug":"Java中常用的Stream流操作","date":"2022-06-14T05:52:31.000Z","updated":"2024-01-21T04:42:33.200Z","comments":true,"path":"post/d861ab24/","link":"","permalink":"http://dcsmf.github.io/post/d861ab24/","excerpt":"","text":"最近在写minecraft服务器的插件，过程中了解了更多Java的Stream流知识，总结在此 集合的分类当我们相对一个集合通过某条件进行分类时，多数情况下用for循环，要么会想到用两个Stream流其实有更简单的方法，执行一次Stream流即可 //原数组List&lt;String&gt; A = Arrays.asList(&quot;Tom&quot;,&quot;Jack&quot;,&quot;John&quot;,&quot;Mike&quot;);//按条件拆分数组Map&lt;Boolean, List&lt;String&gt;&gt; listMap = A.stream() .collect(Collectors.groupingBy(i -&gt; i.contains(&quot;J&quot;)));//满足条件的List&lt;String&gt; B=listMap.get(true);//不满足条件的List&lt;String&gt; C=listMap.get(false); 注意：groupingBy()返回的List&lt;String&gt;可能为null 集合的创建创建一个整数序列创建一个序列在Python一类的编程语言中比较简单，调用对应方法即可但在Java中除了for自己循环创建以外，还可以使用Stream流来操作 //返回一个包含&#123;0,1,2,3,4,5&#125;的List&lt;Integer&gt;集合IntStream.rangeClosed(0,5).boxed().toList() range(int start, int end)不包含endrangeClosed(int start, int end)包含end","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"}],"author":"dcsmf"},{"title":"Java中的联合类型是怎么回事","slug":"Java中的联合类型","date":"2022-04-21T07:57:16.000Z","updated":"2024-01-21T04:42:33.200Z","comments":true,"path":"post/729d788b/","link":"","permalink":"http://dcsmf.github.io/post/729d788b/","excerpt":"","text":"本篇文章以个人经历为引子进行闲谈，并不涉及什么原理 一、何为联合类型当我学习Kotlin时，见到了一种奇怪的范型写法 fun &lt;T, R&gt; callMax(a: T, b: T): R where T: Comparable&lt;T&gt;, T:() -&gt; R, R: Number 在Java里是这样的： public static&lt;T extends Comparable&lt;T&gt; &amp; Supplier&lt;T&gt;, R extends Number&gt; R callMax(T a, T b)&#123;&#125; 这引起了我强烈的好奇，这个&amp;是什么？不难看出这里是“与”的关系，表示范型T只能是实现了Comparable&lt;T&gt;和Supplier&lt;T&gt;两个接口的对象具体来说就是联合类型，即把多个类型的特征结合起来形成的一种不真实存在的类型 部分人将其称为交集类型（Intersection type） 联合类型A &amp; B可看作一个类型U，U类型具有A和B类型的共同的特征，相当于U继承自A和B 二、如何在程序中使用一句话总结：只能用于形参，不能用于实参，只是描述作用，不能当成正常的对象来使用 &amp;符号可以一直连接，但连接时必须把类放在接口前因为Java没有函数类型，所以只能借助接口或者类来间接实现这个联合的功能比如下面这个例子： class MyA &#123; public void t1()&#123; System.out.println(&quot;t1&quot;); &#125;&#125;interface MyB &#123; public default void t2()&#123; System.out.println(&quot;t2&quot;); &#125;&#125;class Combination extends MyA implements MyB &#123; public void t3()&#123; System.out.println(&quot;t3&quot;); &#125;&#125;class MyC&lt;T extends MyA &amp; MyB&gt; &#123; void t4(T t)&#123; t.t1(); t.t2();// 变量t兼具MyA与MyB的方法 System.out.println(&quot;t4&quot;); /* * 不能调用t3，因为传进来的Combination对象 * 只是起一个描述MyA &amp; MyB的作用， * 并不是把Combination对象传进来了 */ //t.t3(); &#125;&#125;public class TestClass &#123; public static void main(String[] args) &#123; // new MyC&lt;MyA &amp; MyB&gt;(); 报错, 实参不能使用联合类型 MyC&lt;Combination&gt; myC = new MyC&lt;&gt;();// 通过间接实现和继承的方式是可以的 myC.t4(new Combination());// 也可以调用其内部的方法 &#125;&#125; 最后的输出结果为： t1t2t4 从上面这个例子可以看出来联合类型在Java联合类型的范型中的作用只能是描述，而非直接使用，我觉得原因在于Java会范型擦除，范型的类型无法保留下来，所以产生了这样奇奇怪怪的写法我还在别人的文章中看到了这种使用方式对lambda表达式进行强制类型转换： public class Test &#123; public static void main(String[] args) &#123; Runnable job =(Runnable &amp; Serializable) () -&gt;System.out.println(&quot;Hello&quot;); Class[] interfaces = job.getClass().getInterfaces(); for (Class i : interfaces) &#123; System.out.println(i.getSimpleName()); &#125; &#125;&#125;/*RunnableSerializable*/ 这也是一种很怪但又不是那么怪的写法，对于不知道这种形式的人来说根本看不大懂不过根据前面学到的东西，这里联合类型其实也是起描述作用，而不能写在lambda表达式的括号（当作实参）里目前了解的就这些了，范型擦除（伪范型）真是一个很神奇的东西呢～","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://dcsmf.github.io/tags/Kotlin/"}],"author":"dcsmf"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"编程杂谈","slug":"编程杂谈","permalink":"http://dcsmf.github.io/categories/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dcsmf.github.io/categories/GitHub/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dcsmf.github.io/tags/Java/"},{"name":"shell","slug":"shell","permalink":"http://dcsmf.github.io/tags/shell/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://dcsmf.github.io/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"http://dcsmf.github.io/tags/Gradle/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dcsmf.github.io/tags/GitHub/"},{"name":"Rust","slug":"Rust","permalink":"http://dcsmf.github.io/tags/Rust/"},{"name":"开源","slug":"开源","permalink":"http://dcsmf.github.io/tags/%E5%BC%80%E6%BA%90/"}]}